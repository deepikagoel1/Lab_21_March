# -*- coding: utf-8 -*-
"""LinReg+Poly-Assignment.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eBqgGSNtztbzElwbgXoSlxgTZgqxclu5

# LINEAR REGRESSION MODEL IMPLEMENTATION
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, accuracy_score, confusion_matrix, classification_report
import seaborn as sns
from sklearn.preprocessing import PolynomialFeatures
import operator

df = pd.read_csv("atmosphere_data1.csv")  # Importing the csv as a dataframe
df.head()

# Find correlation coefficient
df['temperature'].corr(df['pressure'])

"""### Finding correlation between all the attributes"""

print(df['temperature'].corr(df['humidity']))
print(df.corr())

"""## Since all the parameters have negative or less than 0.2 Pearson's correlation with Temperature except Humidity so we have to neglect those attributes.

"""

print("The Data set has {} rows and {} columns\n".format(df.shape[0],df.shape[1]))

"""### Checking Missing Values in the Dataframe"""

#Names of all columns
columns = df.columns.values.tolist()
#Checking for Null Values:
vals=df[columns].isnull().sum()
print(vals)
print("\nTotal NAN values in the File: ",vals.sum())

Y = df["temperature"]
X = df["humidity"]

#Predictor
#[X_train, X_test, Y_train, Y_test] = train_test_split(X, Y,test_size=0.3, random_state=0,shuffle=True)
#plt.figure(figsize=(10,5))
#sns.lmplot(x="humidity", y="temperature", data=df, fit_reg=True, scatter=True)

#Predictor
[X_train, X_test, Y_train, Y_test] = train_test_split(X, Y,test_size=0.3, random_state=5,shuffle=True)
X_train = np.array(X_train)
print(X_train.shape)
X_train = X_train.reshape(-1,1)  #X_train.reshape(573,1)
print(X_train.shape)
print(X_train.ndim)
X_test = np.array(X_test)
X_test = X_test.reshape(-1,1)
print(X_test.ndim)

#Fitting a Linear Regression Model
regressor = LinearRegression()
regressor.fit(X_train,Y_train)
y_pred_train = regressor.predict(X_train)
print(y_pred_train.ndim)
y_pred_test = regressor.predict(X_test)
print(y_pred_test.ndim)

plt.figure(figsize=(15,5))
plt.style.use("dark_background")
plt.scatter(X_train,Y_train,marker = "^", c = "red") # Original data points
plt.plot(X_train,y_pred_train,c= "cyan",lw=3 )  # Predicted line
plt.xlabel("humidity")
plt.ylabel("temperature")
plt.title("Best fit line on the training data")
plt.show()

MSE_train = mean_squared_error(Y_train,y_pred_train)
RMSE_train = np.sqrt(MSE_train)
print("RMSE TRAIN :",RMSE_train)

MSE_test = mean_squared_error(Y_test,y_pred_test)
RMSE_test = np.sqrt(MSE_test)
print("RMSE TEST :",RMSE_test,"\n")

plt.figure(figsize=(15,5))
plt.scatter(Y_test,y_pred_test,marker = "o",color = "orange")
plt.xlabel("actual temperature")
plt.ylabel("predicted temperature")
plt.title("Plot of actual temperature vs predicted temperature")
plt.show()

"""# POLYNOMIAL CURVE FITTING MODEL"""

#Polynomial Model Implementation.
rmse_train={} #To store rmse values for different p
rmse_test={}
ypred_train={}
ypred_test={}
for p in range(10):
    polynomial_features = PolynomialFeatures(degree=p)    
    #print("For degree=",p,", the dimension of polynomial features:",poly_feat.shape)
    polynomial_features.fit(X_train)
    x_poly = polynomial_features.transform(X_train)
    print("For degree=",p,", the dimension of polynomial features:",x_poly.shape)
    # If input is 2D, then degree=2 will produce 6D features, [1,x,y,xy,x^2,y^2]
    regressor = LinearRegression() #Model Will Be Trained.
    regressor.fit(x_poly, Y_train)
    #Model Prediction
    y_pred_train = regressor.predict(polynomial_features.fit_transform(X_train))
    y_pred_test = regressor.predict(polynomial_features.fit_transform(X_test))
    ypred_train[p] = y_pred_train
    ypred_test[p] = y_pred_test
    #RMSE Calculation
    mse_train = mean_squared_error(y_pred_train,Y_train)
    mse_test = mean_squared_error(y_pred_test,Y_test)
    rmse_train[p] = np.sqrt(mse_train)
    rmse_test[p] = np.sqrt(mse_test)

#Checking minimum RMSE Value for Training and Test Data 

print("RMSE TEST :",rmse_test)
Keymintest = min(rmse_test, key = rmse_test.get) 

print("RMSE TRAIN :",rmse_train)
Keymintrain = min(rmse_train, key = rmse_train.get)

print(f"Minimum RMSE Value for Test Data {Keymintest} with value {rmse_test[Keymintest]}")
print(f"Minimum RMSE Value for Training Data {Keymintrain} with value {rmse_train[Keymintrain]}")

#Scatter Plot between Training Data
X_to_plot = X_train.copy()
ypred_plot = ypred_train[9].copy()
plt.figure(figsize=(15,5))
plt.scatter(X_train,Y_train,color = 'blue',marker = '+')
sort_axis = operator.itemgetter(0)
sorted_zip = sorted(zip(X_to_plot,ypred_plot), key = sort_axis)

X_to_plot, ypred_plot = zip(*sorted_zip)
print(f"Y Predict: {type(ypred_plot)} X Plot: {type(X_to_plot)}")
plt.plot(X_to_plot, ypred_plot, color = 'green')
plt.xlabel("Humidity")
plt.ylabel("Temperature")
plt.title("Best fit curve on the training data")

#Training Data between Test Data
X_to_plot = X_test.copy()
ypred_plot = ypred_test[1].copy()
plt.figure(figsize=(15,5))
plt.scatter(X_test,Y_test,color='pink',marker='*')
sort_axis = operator.itemgetter(0)
sorted_zip = sorted(zip(X_to_plot,ypred_plot), key=sort_axis)

X_to_plot, ypred_plot = zip(*sorted_zip)
plt.plot(X_to_plot, ypred_plot, color = 'blue')
plt.xlabel("Humidity")
plt.ylabel("Temperature")
plt.title("Best fit curve on the test data")

plt.figure(figsize=(15,5))
plt.scatter(Y_test,ypred_test[9], marker = "o", c="yellow")
plt.xlabel("actual temperature")
plt.ylabel("predicted temperature")
plt.title("For best degree of polynomial (P=9)")

X_train = X_train.flatten()
print(X_train.ndim)
print(Y_train.ndim)

plt.figure(figsize=(15,5))
df_results = pd.DataFrame({'Actual': X_train, 'Predicted': y_pred_train})
sns.lmplot(x='Actual', y='Predicted', data=df_results, fit_reg=True, scatter=True)
plt.show()

